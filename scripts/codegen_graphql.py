
#!/usr/bin/env python
# -*- coding: utf-8 -*-


"""
GraphQL SDL(.graphql) -> Strawberry types/resolvers/schema 자동 생성기
- 의존: graphql-core, strawberry-graphql
- 사용 예:
    python scripts/codegen_graphql.py --sdl api/NWW.graphql --out api/graphql_gen --package api.graphql_gen
"""
import os, argparse, re
from pathlib import Path
from typing import Dict, Any, List, Tuple

from graphql import build_schema, GraphQLSchema, GraphQLObjectType, GraphQLEnumType, \
    GraphQLInputObjectType, GraphQLScalarType, GraphQLList, GraphQLNonNull, GraphQLNamedType, is_object_type, \
    is_input_object_type, is_enum_type, is_scalar_type

PY_KEYWORDS = {"from","class","def","pass","return","in","is","and","or","not","global","nonlocal","as","if","else","elif","for","while","try","except","finally","with","lambda","yield","await","async","match","case"}

def py_ident(name:str)->str:
    name = re.sub(r'[^0-9a-zA-Z_]', '_', name)
    if name in PY_KEYWORDS: return name + "_"
    if re.match(r'^\d', name): return "_" + name
    return name

def type_to_py(t, nullable=True)->Tuple[str, set]:
    """Return python type string and required imports (typing/strawberry)."""
    imps = set()
    if isinstance(t, GraphQLNonNull):
        inner, imps2 = type_to_py(t.of_type, nullable=False)
        return inner, imps2
    if isinstance(t, GraphQLList):
        inner, imps2 = type_to_py(t.of_type, nullable=True)
        imps |= imps2 | {"List"}
        s = f"List[{inner}]"
        if nullable:
            imps |= {"Optional"}
            s = f"Optional[{s}]"
        return s, imps
    # Named
    named = t.name if hasattr(t, "name") else str(t)
    map_ = {"ID":"strawberry.ID","String":"str","Int":"int","Float":"float","Boolean":"bool"}
    if named in map_:
        s = map_[named]
    else:
        s = named
    if nullable and not s.startswith("Optional["):
        s = f"Optional[{s}]"
        imps |= {"Optional"}
    if s.startswith("strawberry.ID"):
        imps |= {"strawberry"}
    return s, imps

def gather(schema: GraphQLSchema):
    types = {}
    inputs = {}
    enums  = {}
    scalars= {}
    for name, t in schema.type_map.items():
        if name.startswith("__"): 
            continue
        if name in ("Query","Mutation","Subscription"): 
            continue
        if is_object_type(t):
            types[name] = t
        elif is_input_object_type(t):
            inputs[name] = t
        elif is_enum_type(t):
            enums[name] = t
        elif is_scalar_type(t):
            scalars[name] = t
    roots = {
        "Query": schema.query_type,
        "Mutation": schema.mutation_type,
        "Subscription": schema.subscription_type
    }
    return types, inputs, enums, scalars, roots

T_HDR = """# AUTOGENERATED — DO NOT EDIT MANUALLY
from __future__ import annotations
from typing import Optional, List
import strawberry

"""
T_ENUM = """
@strawberry.enum
class {name}:
{members}
"""

T_SCALAR = """
# Custom scalar placeholder — map to Python type as needed.
{pyname} = strawberry.scalar(
    serialize=lambda v: v,
    parse_value=lambda v: v,
    name="{gql}",
    description="Generated scalar placeholder for {gql}"
)
"""

T_OBJ_HDR = "@strawberry.type\nclass {name}:\n"
T_INP_HDR = "@strawberry.input\nclass {name}:\n"
T_FIELD   = "    {fname}: {ftype}\n"
T_DOC     = '    """{doc}"""\n'

S_HDR = """# AUTOGENERATED — schema + resolvers wiring
from __future__ import annotations
from typing import Optional, List
import strawberry
from .types import *
from . import resolvers as R
"""

S_QUERY_HDR = "@strawberry.type\nclass Query:\n"
S_MUT_HDR   = "@strawberry.type\nclass Mutation:\n"
S_SUB_HDR   = "@strawberry.type\nclass Subscription:\n"
S_FIELD_DEF = "    {name}: {rtype} = strawberry.field(resolver=R.{resolver})\n"

S_BUILD = """
schema = strawberry.Schema(query=Query{muta}{sub})
"""

R_HDR = """
# AUTOGENERATED — resolvers stubs
from __future__ import annotations
from typing import Optional, List
# import domain services here

# Query resolvers
{q}

# Mutation resolvers
{m}

# Subscription resolvers
{s}
"""

def gen_types(types, inputs, enums, scalars)->str:
    out = [T_HDR]
    # enums
    for name, e in enums.items():
        members = []
        for k, v in e.values.items():
            members.append(f"    {py_ident(k)} = '{v.value}'")
        out.append(T_ENUM.format(name=name, members="\n".join(members)))
    # scalars
    for name, s in scalars.items():
        if name in ("ID","String","Int","Float","Boolean"): 
            continue
        out.append(T_SCALAR.format(pyname=py_ident(name), gql=name))
    # inputs
    for name, obj in inputs.items():
        out.append(T_INP_HDR.format(name=name))
        if not obj.fields:
            out.append("    pass\n")
        else:
            if obj.description:
                out.append(T_DOC.format(doc=obj.description.replace('\"\"\"','\\\"\\\"\\\"')))
            for fname, f in obj.fields.items():
                t, _ = type_to_py(f.type, nullable=True)
                out.append(T_FIELD.format(fname=py_ident(fname), ftype=t))
        out.append("\n")
    # objects
    for name, obj in types.items():
        out.append(T_OBJ_HDR.format(name=name))
        if obj.description:
            out.append(T_DOC.format(doc=obj.description.replace('\"\"\"','\\\"\\\"\\\"')))
        if not obj.fields:
            out.append("    pass\n\n")
            continue
        for fname, f in obj.fields.items():
            t, _ = type_to_py(f.type, nullable=True)
            out.append(T_FIELD.format(fname=py_ident(fname), ftype=t))
        out.append("\n")
    return "".join(out)

def gen_schema(roots, types, inputs)->str:
    out = [S_HDR]
    # Query
    q_lines = []
    if roots["Query"]:
        out.append(S_QUERY_HDR)
        for fname, f in roots["Query"].fields.items():
            rtype, _ = type_to_py(f.type, nullable=True)
            rname = py_ident(f"resolve_{fname}")
            q_lines.append(S_FIELD_DEF.format(name=py_ident(fname), rtype=rtype, resolver=rname))
        if not q_lines: out.append("    pass\n")
        else: out += q_lines
        out.append("\n")
    # Mutation
    m_lines = []
    if roots["Mutation"]:
        out.append(S_MUT_HDR)
        for fname, f in roots["Mutation"].fields.items():
            rtype, _ = type_to_py(f.type, nullable=True)
            rname = py_ident(f"resolve_{fname}")
            m_lines.append(S_FIELD_DEF.format(name=py_ident(fname), rtype=rtype, resolver=rname))
        if not m_lines: out.append("    pass\n")
        else: out += m_lines
        out.append("\n")
    # Subscription
    s_lines = []
    if roots["Subscription"]:
        out.append(S_SUB_HDR)
        for fname, f in roots["Subscription"].fields.items():
            rtype, _ = type_to_py(f.type, nullable=True)
            rname = py_ident(f"resolve_{fname}")
            s_lines.append(S_FIELD_DEF.format(name=py_ident(fname), rtype=rtype, resolver=rname))
        if not s_lines: out.append("    pass\n")
        else: out += s_lines
        out.append("\n")
    out.append(S_BUILD.format(muta=", mutation=Mutation" if roots["Mutation"] else "", sub=", subscription=Subscription" if roots["Subscription"] else ""))
    return "".join(out)

def gen_resolvers(roots)->str:
    def make_block(root):
        if not root: return ""
        lines = []
        for fname, f in root.fields.items():
            rname = py_ident(f"resolve_{fname}")
            lines.append(f"def {rname}(*args, **kwargs):\\n    raise NotImplementedError('{rname} not implemented')\\n")
        return "\\n".join(lines) if lines else ""
    return R_HDR.format(
        q=make_block(roots["Query"]) or "def resolve_ping():\n    return 'pong'\n",
        m=make_block(roots["Mutation"]) or "def resolve_noop():\n    return True\n",
        s=make_block(roots["Subscription"]) or "def resolve_stream():\n    yield 'tick'\n"
    )

def main():
    ap = argparse.ArgumentParser()
    ap.add_argument("--sdl", default="api/NWW.graphql")
    ap.add_argument("--out", default="api/graphql_gen")
    ap.add_argument("--package", default="api.graphql_gen")
    args = ap.parse_args()

    sdl_path = Path(args.sdl)
    assert sdl_path.exists(), f"SDL not found: {sdl_path}"
    sdl = sdl_path.read_text("utf-8")
    schema = build_schema(sdl)

    types, inputs, enums, scalars, roots = gather(schema)

    out_dir = Path(args.out)
    (out_dir).mkdir(parents=True, exist_ok=True)
    (out_dir / "__init__.py").write_text("# generated package\n", encoding="utf-8")
    (out_dir / "types.py").write_text(gen_types(types, inputs, enums, scalars), encoding="utf-8")
    (out_dir / "schema.py").write_text(gen_schema(roots, types, inputs), encoding="utf-8")
    (out_dir / "resolvers.py").write_text(gen_resolvers(roots), encoding="utf-8")

    print("generated:", out_dir/"types.py")
    print("generated:", out_dir/"schema.py")
    print("generated:", out_dir/"resolvers.py")
    print("Done. Import with: from", args.package, "import schema")

if __name__ == "__main__":
    main()
